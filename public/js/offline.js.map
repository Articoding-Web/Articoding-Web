{"version":3,"file":"offline.js","sources":["../../node_modules/uuid/dist/esm-browser/rng.js","../../node_modules/uuid/dist/esm-browser/stringify.js","../../node_modules/uuid/dist/esm-browser/native.js","../../node_modules/uuid/dist/esm-browser/v4.js","../../src/SPA/utils.ts","../../src/ServiceWorker/offline.ts"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 as uuidv4 } from 'uuid';\nlet MY_UUID = localStorage.getItem('MY_UUID');\nif (!MY_UUID) {\n    MY_UUID = uuidv4();\n    localStorage.setItem('MY_UUID', MY_UUID);\n}\nexport function getSpecificUUID() {\n    if (!MY_UUID) {\n        MY_UUID = uuidv4();\n        localStorage.setItem('MY_UUID', MY_UUID);\n    }\n    return MY_UUID;\n}\nexport class HTTPError extends Error {\n    status;\n    constructor(status, message) {\n        super(message);\n        this.status = status;\n    }\n}\n/**\n *\n * @param {URL} endpoint endpoint where the call should be made\n * @param {String} method \"GET\" is the only method supported\n * @returns json response\n */\nexport async function fetchRequest(endpoint, method, data, credentials) {\n    try {\n        const response = await fetch(endpoint, {\n            method,\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            credentials: credentials,\n            body: data,\n        });\n        if (!response.ok) {\n            throw new HTTPError(response.status, `${method} request to ${endpoint} failed with status ${response.status}`);\n        }\n        return await response.json();\n    }\n    catch (error) {\n        console.error(error);\n        throw error;\n    }\n}\n/**\n *\n * @param {HTMLDivElement} divElement where the items generated are appended\n * @param {Array} items items used to generate html that is inserted\n * @param {Function} htmlGenerator html string generator to process items and generate html\n */\nexport async function fillContent(divElement, items, htmlGenerator) {\n    divElement.innerHTML = \"\";\n    for (let item of items) {\n        divElement.insertAdjacentHTML(\"beforeend\", await htmlGenerator(item));\n    }\n}\nuuidv4();\n//# sourceMappingURL=utils.js.map","/* (function () {\n    if (!navigator || !navigator.serviceWorker) return;\n    caches.keys().then(function (keys) {\n        return keys.filter(function (key) {\n            return key.includes('_levels');\n        }).forEach(function (key) {\n            const list = document.querySelector('#principal');\n            list.innerHTML = '';\n            caches.open(key).then(function (cache) {\n                cache.keys().then(function (keys) {\n                    list.innerHTML = \"<ul>\" +\n                            keys.map(function(key) {\n                                return '<li><a href=\"' + key.url + '\">' + key.url + '</a></li>';\n                            }).join('')\n                            + \"</ul>\"\n                });\n            });\n        });\n    });\n})(); */\nimport { fetchRequest } from \"../SPA/utils\";\n// import playLevelById from \"../SPA/loaders/levelPlayerLoader\";\nfunction generateLevelDiv(level) {\n    if (!level) {\n        throw new Error(\"Invalid level data\");\n    }\n    const { id, miniature, title, description = \"Blockleap level\" } = level;\n    return `\n        <div class=\"col\">\n          <div class=\"card mx-auto border-dark\">\n            <a class=\"getLevel\" href=\"/level/${id}\">\n              <div class=\"row g-0 text-dark\">\n                <div class=\"col-md-3\">\n                  ${miniature\n        ? `<img src=\"${miniature}\" class=\"img-fluid rounded-start\" alt=\"${title}\">`\n        : \"\"}\n                </div>\n                <div class=\"col-md-9\">\n                  <div class=\"card-body\">\n                    <div class=\"row row-cols-1 row-cols-md-2\">\n                      <div class=\"col\">\n                        <h5 class=\"card-title\">${title}</h5>\n                        <p class=\"card-text\">${description}</p>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </a>\n          </div>\n        </div>`;\n}\nasync function setContent() {\n    history.pushState({}, \"\", \"offline.html\");\n    if (!navigator || !navigator.serviceWorker)\n        return;\n    console.warn(\"Llego a setContent\");\n    await caches.keys().then(function (keys) {\n        return keys.filter(function (key) {\n            return key.includes('_levels');\n        }).forEach(function (key) {\n            console.log(\"Cache name:\", key);\n            const list = document.getElementById(\"principal\");\n            console.log(list);\n            caches.open(key).then(function (cache) {\n                cache.keys().then(function (keys) {\n                    list.innerHTML = \"<ul>\" +\n                        keys.map(async function (key) {\n                            console.log(key);\n                            const level = await fetchRequest(key.url, \"GET\");\n                            return `<li>${generateLevelDiv(level)}</li>`;\n                        }).join('')\n                        + \"</ul>\";\n                });\n            });\n        });\n    });\n}\n;\n// Add click event listener for each level\nasync function load() {\n    const levels = document.querySelectorAll(\".offlineLevel\");\n    levels.forEach(level => level.addEventListener(\"click\", function (event) {\n        event.preventDefault();\n        const id = this.href.split(\"level/\")[1];\n    }));\n}\n(async function () {\n    await setContent();\n    load();\n})();\n//# sourceMappingURL=offline.js.map"],"names":["getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","MY_UUID","localStorage","getItem","uuidv4","setItem","HTTPError","status","constructor","message","super","this","async","setContent","history","pushState","navigator","serviceWorker","console","warn","caches","keys","then","filter","key","includes","forEach","log","list","document","getElementById","open","cache","innerHTML","map","level","id","miniature","title","description","generateLevelDiv","endpoint","method","data","credentials","response","fetch","headers","body","ok","json","error","fetchRequest","url","join","querySelectorAll","addEventListener","event","preventDefault","href","split","load"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}